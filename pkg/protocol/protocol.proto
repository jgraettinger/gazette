syntax = "proto3";

package protocol;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;

// Status is a response status code, used universally across Gazette RPC APIs.
enum Status {
  OK = 0;
  JOURNAL_EXISTS = 1;
  JOURNAL_NOT_FOUND = 2;

  NO_JOURNAL_PRIMARY_BROKER = 3;
  NOT_JOURNAL_PRIMARY_BROKER = 4;

  INSUFFICIENT_JOURNAL_BROKERS = 5;
  NOT_JOURNAL_BROKER = 6;

  OFFSET_NOT_YET_AVAILABLE = 7;

  WRONG_ROUTE = 9;
  FRAGMENT_MISMATCH = 10;
}

// CompressionCode defines codecs known to Gazette.
enum CompressionCodec {
  NONE = 0;
  GZIP = 1;
  ZSTANDARD = 2;
  SNAPPY = 3;

  // CONTENT_ENCODING is not itself a CompressionCodec, but instead conveys
  // that the actual codec is stored under the Content-Encoding header of
  // the Fragment within the backing store.
  //
  // Deprecated. Going forward, we prefer to use explicit codec extensions.
  CONTENT_ENCODING = 4;
}

// Label defines a key & value pair which can be attached to entities like
// JournalSpecs and BrokerSpecs. Labels may be used to provide identifying
// attributes which do not directly imply semantics to the core system, but
// are meaningful to users or for higher-level Gazette tools. For example,
// topics of JournalSpecs are represented as the well-known label "topic".
message Label {
  option (gogoproto.goproto_unrecognized) = false;
  string name = 1;
  string value = 2;
}

// LabelSet is a collection of labels and their values.
message LabelSet {
  // Labels of the set. Instances must be unique and in sorted order.
  repeated Label labels = 1 [(gogoproto.nullable) = false];
}

// LabelSelector defines a filter over LabelSets.
message LabelSelector {
  // Include is Labels which must be matched for a LabelSet to be selected. If
  // empty, all Labels are included. An include Label with empty ("") value is
  // matched by a Label of the same name having any value.
  LabelSet include = 1 [(gogoproto.nullable) = false];
  // Exclude is Labels which cannot be matched for a LabelSet to be selected. If
  // empty, no Labels are excluded. An exclude Label with empty ("") value
  // excludes a Label of the same name having any value.
  LabelSet exclude = 2 [(gogoproto.nullable) = false];
}

// JournalSpec describes a Journal and its configuration.
message JournalSpec {
  // Name of the Journal.
  string name = 1 [(gogoproto.casttype) = "Journal"];

  // Desired replication of this Journal. This defines the Journal's tolerance
  // to broker failures before data loss can occur (eg, a replication factor
  // of three means two failures are tolerated).
  int32 replication = 2;

  // User-defined Labels of this JournalSpec.
  LabelSet labels = 3 [(gogoproto.nullable) = false];

  // Fragment is JournalSpec configuration which pertains to the creation,
  // persistence, and indexing of the Journal's Fragments.
  message Fragment {
    // Target content length of each Fragment. In normal operation after Fragments
    // reach at least this length, they will be closed and new ones begun. Note
    // lengths may be smaller at times (eg, due to changes in Journal routing
    // topology). Content length differs from Fragment file size, in that the
    // former reflects uncompressed bytes.
    int64 length = 1;

    // Codec used to compress Journal Fragments.
    CompressionCodec compression_codec = 2;

    // Storage backend base path for this Journal's Fragments. Must be in URL
    // form, with the choice of backend defined by the scheme. The full path of
    // a Journal's Fragment is derived by joining the fragment_store path with
    // the Fragment's ContentPath. Eg, given a fragment_store of
    // "s3://My-AWS-bucket/a/prefix" and a JournalSpec of name "my/journal",
    // a complete Fragment path might be:
    //   "s3://My-AWS-bucket/a/prefix/my/journal/000123-000456-789abcdef.gzip
    //
    // Multiple fragment_stores may be specified, in which case the Journal's
    // Fragments are the union of all Fragments present across all stores, and
    // new Fragments always persist to the first specified store. This can be
    // helpful in performing incremental migrations, where new Journal content is
    // written to the new store, while content in the old store remains available
    // (and, depending on fragment_retention or recovery log pruning, may
    // eventually be removed).
    //
    // If no fragment_stores are specified, the Journal is still useable but will
    // not persist Fragments to any a backing fragment store. This allows for
    // real-time streaming use cases where reads of historical data are not needed.
    repeated string stores = 3 [(gogoproto.casttype) = "FragmentStore"];

    // Interval of time between refreshes of remote Fragment listings from
    // configured fragment_stores.
    google.protobuf.Duration refresh_interval = 4 [(gogoproto.stdduration) = true, (gogoproto.nullable) = false];

    // Retention duration for historical Fragments of this Journal within the
    // Fragment stores. If zero, Fragments are retained indefinetely.
    google.protobuf.Duration retention = 5 [(gogoproto.stdduration) = true, (gogoproto.nullable) = false];
  }
  Fragment fragment = 4 [(gogoproto.nullable) = false];

  // If true, this Journal will not accept Append requests.
  bool read_only = 6;
}

// BrokerSpec describes a Gazette broker and its configuration.
message BrokerSpec {
  message ID {
    // "Zone" in which the Broker is running. Zones may be AWS, Azure, or Google
    // Cloud Platform zone identifiers, or rack locations within a colo, or
    // given some other custom meaning. Gazette will replicate every Journal
    // across multiple zones, and seeks to minimize traffic which must cross zones
    // (for example, by proxying reads to a broker in the current zone).
    string zone = 1;
    // Unique suffix of the broker within |zone|.
    string suffix = 2;
  }
  ID id = 1 [(gogoproto.nullable) = false];
  // Advertised URL of the Broker.
  string endpoint = 2 [(gogoproto.casttype) = "Endpoint"];
  // Maximum number of assigned Journal replicas.
  uint32 journal_limit = 3;
}

// Fragment is a content-addressed description of a contiguous Journal span,
// defined by the [begin, end) offset range covered by the Fragment and the
// SHA1 sum of the corresponding Journal content.
message Fragment {
  // Journal of the Fragment.
  string journal = 1 [(gogoproto.casttype) = "Journal"];
  // Begin (inclusive) and end (exclusive) offset of the Fragment within the Journal.
  int64 begin = 2;
  int64 end = 3;
  // SHA1 sum of the Fragment's content.
  SHA1Sum sum = 4 [(gogoproto.nullable) = false];
  // Codec with which the Fragment's content is compressed.
  CompressionCodec compression_codec = 5;
  // Fragment store which backs the Fragment. Empty if the Fragment has yet to
  // be persisted and is still local to a Broker.
  string backing_store = 6 [(gogoproto.casttype) = "FragmentStore"];
  // Modification timestamp of the Fragment within the backing store.
  google.protobuf.Timestamp mod_time = 7 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
}

// SHA1Sum is a 160-bit SHA1 digest.
message SHA1Sum {
  option (gogoproto.goproto_unrecognized) = false;
  option (gogoproto.equal) = true;

  fixed64 part1 = 1;
  fixed64 part2 = 2;
  fixed32 part3 = 3;
}

message ReadRequest {
  // Journal to be read.
  string journal = 1 [(gogoproto.casttype) = "Journal"];
  // Desired offset to begin reading from. Value -1 has special handling, where
  // the read is performed from the current write head. All other positive
  // values specify a desired exact byte offset to read from. If the offset is
  // not available (eg, because it represents a portion of Journal which has
  // been permantently deleted), the broker will return the next available
  // offset. Callers should therefore always inspect the ReadResponse offset.
  int64 offset = 2;
  // Whether the operation should block until content becomes available.
  // OFFSET_NOT_YET_AVAILABLE is returned if a non-blocking read has no ready content.
  bool block = 3;
  // If do_not_proxy is true, the broker will not proxy the read to another
  // broker, or open and proxy a remote Fragment on the client's behalf.
  bool do_not_proxy = 4;
  // If metadata_only is true, the broker will respond with Journal and
  // Fragment metadata but not content.
  bool metadata_only = 5;
  // If set, minimum EtcdCursor under which the request should be processed.
  EtcdCursor etcd = 6;
}

message ReadResponse {
  Status status = 1;
  // The effective offset of the read. See ReadRequest offset.
  int64 offset = 2;
  // The offset to next be written, by the next append transaction served by
  // broker. In other words, the last offset through which content is
  // available to be read from the Journal.
  int64 write_head = 3;
  // The route of responsible brokers for the current Journal.
  Route route = 4;
  // Fragment to which the offset was mapped.
  Fragment fragment = 5;
  // If Fragment is remote, a URL from which it may be directly read.
  string fragment_url = 6;
  // Content of the read.
  bytes content = 7;
  // Etcd cursor of the broker which generated the response.
  EtcdCursor etcd = 8;
}

// There are two types of AppendRequest:
//  * Initial request - Journal is set (only).
//  * Content chunk - Content is set (only).
message AppendRequest {
  // Journal to be appended to.
  string journal = 1 [(gogoproto.casttype) = "Journal"];
  // Content to be appended.
  bytes content = 5;
}

message AppendResponse {
  Status status = 1;
  // The route of responsible brokers for the current Journal.
  Route route = 2;
  // On Status OK, the Fragment which places the committed Append
  // content within the Journal.
  Fragment commit = 3;
}

// Three types of ReplicateRequest:
//  * Initial request - Journal, Route, Proposal, and Acknowledge all set.
//  * Streamed commit - Proposal and (optionally) Acknowledge are set.
//  * Streamed content - Content and ContentDelta are set.
message ReplicateRequest {
  // Journal to be replicated to.
  string journal = 1 [(gogoproto.casttype) = "Journal"];
  // Route of the transaction, also known and verified by all replicas.
  Route route = 2;
  // Proposed Fragment to commit. Independently verified by each Journal replica.
  Fragment proposal = 3;
  // If |commit| is set, if |acknowledge| than the replica will send an
  // acknowledgement ReplicateResponse.
  bool acknowledge = 4;
  // Content to be replicated.
  bytes content = 5;
  // Delta offset of |content| relative to current Fragment |end|.
  int64 content_delta = 6;

  etcdserverpb.ResponseHeader etcd = 7;

}

message ReplicateResponse {
  Status status = 1;
  // If status is WRONG_ROUTE_TOKEN, then |route| is the replica's Route
  // which was found to be inconsistent with the request Route.
  Route route = 2;
  // If status is FRAGMENT_MISMATCH, then |fragment| is the replica's
  // Fragment at the current journal head, which was found to be inconsistent
  // with the request |commit| Fragment.
  Fragment fragment = 3;
}

// Route captures the current topology of a Journal and the brokers serving it.
message Route {
  option (gogoproto.goproto_unrecognized) = false;

  // Etcd revision at which this Route was produced. |revision| enables the
  // comparison of non-equivalent Routes, to determine which is more recent.
  int64 revision = 1;
  // Brokers of the Route, ordered on ascending BrokerSpec (zone, name).
  // Note that only a Route-relevant subset of the spec is populated
  // (specifically name, zone, & endpoint).
  repeated BrokerSpec.ID brokers = 2 [(gogoproto.nullable) = false];
  // Index of the BrokerSpec serving as primary within |brokers|,
  // or -1 of no broker is currently primary.
  int32 primary = 3;
  // Endpoints of each Route Broker. If not empty, |endpoints| has the same
  // length and order as |brokers|, and captures the endpoint of each one.
  repeated string endpoints = 4 [(gogoproto.casttype) = "Endpoint"];
}

// EtcdCursor represents the effective Etcd ClusterId and Revision under which
// a Gazette broker is operating in its processing of requests and responses.
// Its inclusion allows brokers to reason about relative "happened before"
// Revision ordering of apparent routing conflicts in proxied or replicated
// requests, as well as enabling sanity checks over equality of Etcd ClusterId
// (and not, for example, allowing for split-brain scenarios where different
// brokers are working off of different Etcd clusters). EtcdHeader
// is isomorphic to Etcd's etcdserverpb.ResponseHeader.
message EtcdCursor {
  // cluster_id is the ID of the cluster.
  uint64 cluster_id = 1;
  // member_id is the ID of the member.
  uint64 member_id = 2;
  // revision is the Etcd key-value store revision when the request was applied.
  int64 revision = 3;
  // raft_term is the raft term when the request was applied.
  uint64 raft_term = 4;
}

service Broker {
  rpc Read(ReadRequest) returns (stream ReadResponse);
  rpc Append(stream AppendRequest) returns (AppendResponse);
  rpc Replicate(stream ReplicateRequest) returns (stream ReplicateResponse);
}
